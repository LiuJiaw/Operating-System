;本程序在编译时，起始地址为0x7c00
SECTION MBR vstart=0x7c00
	;用cs段寄存器的值去初始化其他寄存器的值
	mov ax, cx
	mov ds, ax
	mov es, ax
	mov ss, ax
	mov fs, ax
	;然后初始化栈指针，因为0x7c00以下暂时安全区域
	mov sp, 0x7c00



;清屏，利用0x06号功能，上卷全部行，即可实现清屏功能
;AH为功能号，即0x06， AL为上卷行数，当其为0时，表示全部，由此ax可设为0x600
;BH为上卷行属性，在这里我们设为0x07，bx值为0x700
;CL、CH依次代表左上角横纵坐标，因此cx为0
;DL、DH依次代表右下角横纵坐标，因为VGA文本模式中，一行80字符，共25行
;故坐标为(79,24)，即dx的值为0x184f
	mov ax, 0x600
	mov bx, 0x700
	mov cx, 0
	mov dx, 0x184f

	int 0x10



;获取光标位置
;3号子功能是获取光标位置，需存入ah寄存器
;bh寄存器存储待获取光标的页号
	mov ah, 3
	mov bh, 0

	int 0x10



;打印字符串
	;还是用10h中断,不过这次是调用13号子功能打印字符串
   	mov ax, message 
   	mov bp, ax		

   	;光标位置要用到dx寄存器中内容,cx中的光标位置可忽略
	;cx 为串长度,不包括结束符0的字符个数
   	mov cx, 5		
	;子功能号13是显示字符及属性,要存入ah寄存器,
	;al设置写字符方式 ah=01: 显示字符串,光标跟随移动
   	mov ax, 0x1301		
	;bh存储要显示的页号,此处是第0页，bl中是字符属性, 属性黑底绿字
   	mov bx, 0x2		
		
  	int 0x10		




;打印字符串结束
	;使程序悬停在此，实际上执行死循环
	jmp $
	;定义打印的字符串
	message db "1 MBR"
	;$-$$求出的是距离段起始地址的偏移量，因为0x55和0xaa要占两个字节
	;所以需要将剩余的510-($-$$)个字节用0填满
	times 510-($-$$) db 0

	db 0x55, 0xaa













